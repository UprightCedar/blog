# 实现一个简单的模块加载器
#### 本文的目标是实现一个浏览器端的模块加载器（类似于requirejs）

## - requirejs
#### 我们先看一下requirejs的用法

```
//index.html
<html>
    <head>
        <script src="require.js" data-main="index.js"></script>
    </head>
    <body>
    </body>
</html>


//index.js
define(['module.js'], function(module) {
    // do something
})

//module.js 
define(function() {
    // do something
})
```
#### requirejs遵循AMD规范，模块是由define定义，define的第一个参数是依赖项（数组），当然也可以没有依赖。主模块是在引入requirejs的时候通过data-main属性指明的。

## - 代码

```
(function() {
    //模块的缓存
    var _modules = {}
    var proxy = {
        task: {},
        processDep: function(name, dep, cb) {
            var newDep = []
            dep = dep.map(function(item) {
                return fixUrl(name, item)
            })
            for (var i=0; i<dep.length; i++) { 
                //_modules已经存在的模块不需要再添加至dep中了
                if (!_modules[dep[i]]) { 
                    //如果task中已经存在模块  说明已经下载了模块但是模块的依赖还没有解析  但此时不需要再次下载模块了
                    if (this.task[dep[i]]) {
                        newDep.push(dep[i])
                    } else {
                        newDep.push(dep[i])
                        loadModule(dep[i])
                    }
                }
            }
            //假如依赖项已经全部存在_modules中了  直接解析模块
            if (!newDep.length) {
                var arr = [] 
                for(var i=0; i<dep.length; i++) {
                    arr.push(_modules[dep[i]])
                }
                _modules[name] = cb.apply(null, arr)     
                proxy.emit(name)            
                return
            }
            this.task[name] = {
                dep: newDep,
                cb: function() {
                    var arr = [] 
                    //将依赖的模块作为参数注入
                    for(var i=0; i<dep.length; i++) {
                        arr.push(_modules[dep[i]])
                    }
                    _modules[name] = cb.apply(null, arr) 
                    delete proxy.task[name]
                    //emit此模块已解析完毕
                    proxy.emit(name)
                }
            }
        },
        emit: function(name) {
            var names = Object.keys(this.task)
            for (var i=0; i<names.length; i++) {
                (function(i, This){
                    var dep = This.task[names[i]].dep
                    for (var j=0; j<dep.length; j++) {
                        if (name === dep[j]) {
                            dep.splice(j, 1)
                            break
                        }
                    } 
                    //假如模块依赖的所有模块已经解析完毕则解析模块
                    if (!dep.length) {
                        This.task[names[i]].cb()
                    }
                })(i, this)
            }
        }
    }

    //将模块插入到文档
    function loadModule(src) {
        var script = document.createElement('script')
        script.src = src
        document.body.appendChild(script)
    }

    //添加主模块
    (function() {
        var aScript = document.getElementsByTagName('script')
        var src = ''
        for (var i=0; i<aScript.length; i++) {
            var main = aScript[i].getAttribute('data-main')
            main = fixUrl(window.location.href, main)
            if (main) {
                src = main
                break
            }
        }
        loadModule(src)
    })()

    //解析路径
    function fixUrl(originUrl, relativeUrl) {
        //匹配 define(['a.js'], fn)
        var reg1 = /^[^\.]+/
        //匹配 define(['./a.js'], fn)
        var reg2 = /^\.\//
        //匹配 define(['../a.js'], fn)
        var reg3 = /^((\.\.\/)+)(.+)/
        if (reg1.test(relativeUrl)) {
            var last = originUrl.match(/.*?(\/[^\/]+)+/) 
            return originUrl.replace(last[1], '/' + relativeUrl)
        } else if (reg2.test(relativeUrl)) {
            var last = originUrl.match(/.*?(\/[^\/]+)+/) 
            return originUrl.replace(last[1], '/' + relativeUrl.slice(2))
        } else if (reg2.test(relativeUrl)) {
            var arr = []
            var result = /^((\.\.\/)+)(.+)/.exec(relativeUrl)
            var length = result[1].length
            var file = result[3]
            var reg4 = /\/[\w|\.]+/
            while (reg4.test(originUrl)) {
                arr.push(reg4.exec(originUrl)[0])
            }
            var str = arr.splice(-(length+1)).join('')
            return originUrl.replace(str, '/' + file)
        }
    }

    function define(dep, cb) {
        var name = document.currentScript.src
        if (_modules[name]) return 
        //如果不存在依赖项  则直接解析模块  并emit模块完成
        if (arguments.length === 1) {
            cb = dep
            _modules[name] = cb()
            proxy.emit(name)
        //存在依赖项则解析依赖
        } else {
            proxy.processDep(name, dep, cb)
        }
    }

    window.define = define
})()

```
## - 需要解决四个问题：解析路径、下载模块、解析模块依赖、解析模块。这里面主要的难点是解析路径与解析模块依赖。
### 解析路径
我们知道一个js文件就代表一个模块，那么怎么标识模块（唯一性）?文件的路径是不二的选择，所以我们需要一个函数来解析路径。
### 解析模块依赖
第二个需要解决的问题是解析模块的依赖，因为当你下载模块之后假如这个模块还需要依赖别的模块，则必须要等到依赖的模块下载执行之后才能继续执行。解决的思路是每解析完一个模块就emit一个事件（我完成了啦），然后遍历所有的模块，如果其依赖项含有已完成的模块，则将其从依赖项中去除，如果去除后其依赖项的长度等于零了，说明其依赖已经解析完毕，那么就可以解析此模块了，解析完此模块也emit一个此模块已完成。

## - 后记
#### 写这个加载器遇到的最大困难是解析模块路径，对正则有一定的要求，自己这一块很欠缺，文中混乱的完成了相对路径的解析，后续需要改写。